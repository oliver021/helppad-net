using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Helppad
{
    /// <summary>
    /// The source of a state pausable and cancellable process.
    /// Similar like <see cref="CancellationTokenSource"/> but with pause state.
    /// This class help to emulate pause state without blocking way using async way.
    /// </summary>
    public class ProcessStateSource : IDisposable
    {
        /// <summary>
        /// Evento to set and unset the pause state.
        /// </summary>
        private readonly ManualResetEventSlim _pauseHandler;

        /// <summary>
        /// Event to notify of pause position.
        /// </summary>
        private readonly ManualResetEventSlim _frontHandler;

        /// <summary>
        /// The cancellation token.
        /// </summary>
        private readonly CancellationTokenSource _cts;

        /// <summary>
        /// Parameterless
        /// </summary>
        public ProcessStateSource()
        {
            _pauseHandler = new ManualResetEventSlim(true);
            _frontHandler = new ManualResetEventSlim(false);
            _cts = new CancellationTokenSource();
        }

        /// <summary>
        /// The state process token to recive notifications.
        /// </summary>
        public ProcessStateToken State => new()
        {
            _ct = _cts.Token,
            _frontHandler = _frontHandler,
            _pauseHandler = _pauseHandler,
        };

        /// <summary>
        /// Communicates a request for cancellation.
        /// </summary>
        public void Cancel()
        {
            _cts.Cancel();
        }

        /// <summary>
        /// Communicates a request for cancellation, and specifies whether remaining callbacks and cancelable operations should be processed.
        /// </summary>
        /// <param name="throwOnFirstException"></param>
        public void Cancel(bool throwOnFirstException)
        {
            _cts.Cancel(throwOnFirstException);
        }

        /// <summary>
        /// Schedules a cancel operation on this System.Threading.CancellationTokenSource 
        /// after the specified number of milliseconds.
        /// </summary>
        /// <param name="millisecondsDelay"></param>
        public void CancelAfter(int millisecondsDelay)
        {
            _cts.CancelAfter(millisecondsDelay);
        }

        /// <summary>
        /// Schedules a cancel operation on this System.Threading.CancellationTokenSource
        /// after the specified time span.
        /// </summary>
        /// <param name="delay"></param>
        public void CancelAfter(TimeSpan delay)
        {
            _cts.CancelAfter(delay);
        }

        /// <summary>
        /// Notify the subprocess that pause is setted.
        /// </summary>
        /// <param name="ms"></param>
        /// <param name="cancellation"></param>
        /// <returns></returns>
        public async Task<bool> PauseAsync(int ms, CancellationToken cancellation = default)
        {
            // request pause handler
            _pauseHandler.Reset();

            // wait for response
            var success = await _frontHandler.WaitHandle.WaitOneAsync(ms, cancellation);

            if (success is false)
            {
                _pauseHandler.Set();
            }

            return success;
        }

        /// <summary>
        /// Unset the pause state to notify that subprocess it should be continue.
        /// </summary>
        /// <returns>
        /// True if the pause is unset; otherwise false if the pause had not been set.
        /// </returns>
        public bool Run()
        {
            if (_pauseHandler.IsSet)
            {
                return false;
            }

            // open the pause handler to continue run
            _pauseHandler.Set();

            // close the front handler
            _frontHandler.Reset();

            return true;
        }

        /// <summary>
        /// Releases all resources used by the current instance of the
        /// System.Threading.CancellationTokenSource class.
        /// </summary>
        public void Dispose()
        {
            _cts.Dispose();
            _frontHandler.Dispose();
            _pauseHandler.Dispose();
        }
    }

    /// <summary>
    /// Represents a state token for processes that are divided into steps 
    /// that respond to a possible pause and cancel request from the user.
    /// This token is generated by its own source <see cref="ProcessStateSource"/>
    /// </summary>
    public struct ProcessStateToken
    {
        /// <summary>
        /// Internal idnciator.
        /// The event to know if the pasued is set.
        /// </summary>
        internal ManualResetEventSlim _pauseHandler;

        /// <summary>
        /// Internal idnciator.
        /// The event to notify the source that the current process is at the
        /// pause position.
        /// </summary>
        internal ManualResetEventSlim _frontHandler;

        /// <summary>
        /// Internal idnciator.
        /// The cancellation token.
        /// </summary>
        internal CancellationToken _ct;

        /// <summary>
        /// Gets whether cancellation has been requested for this state.
        /// </summary>
        public bool IsCancellationRequested => _ct.IsCancellationRequested;

        /// <summary>
        /// Gets whether pause has been requested for this state.
        /// </summary>
        public bool IsPausedRequested => IsCancellationRequested is false && _pauseHandler.IsSet is false;

        /// <summary>
        /// Gets whether pause has been unset for this state and can continue..
        /// </summary>
        public bool IsRunning => IsCancellationRequested is false && _pauseHandler.IsSet is true;

        /// <summary>
        /// Throws a <see cref="OperationCanceledException"/> if this token has had cancellation requested.
        /// </summary>
        /// <exception cref="OperationCanceledException">Throw if the cancellation  has been requested for this state.</exception>
        public void ThrowIfCancellationRequested()
        {
            _ct.ThrowIfCancellationRequested();
        }

        /// <summary>
        /// Registers a delegate that will be called when this state notify
        /// the request cancellation.
        /// </summary>
        /// <param name="action"></param>
        public void Register(Action action)
        {
            Review.NotNullArgument(action);
            _ct.Register(action);
        }

        /// <summary>
        /// Registers a delegate that will be called when this state notify
        /// the request cancellation.
        /// </summary>
        /// <param name="action"></param>
        /// <param name="useSynchronizationContext"></param>
        public void Register(Action action, bool useSynchronizationContext)
        {
            Review.NotNullArgument(action);
            _ct.Register(action, useSynchronizationContext);
        }

        /// <summary>
        /// Registers a delegate that will be called when this state notify
        /// the request cancellation.
        /// </summary>
        /// <param name="action"></param>
        /// <param name="state"></param>
        public void Register(Action<object> action, object state)
        {
            Review.NotNullArgument(action);
            _ct.Register(action, state);
        }

        /// <summary>
        /// Registers a delegate that will be called when this state notify
        /// the request cancellation.
        /// </summary>
        /// <param name="action"></param>
        /// <param name="state"></param>
        /// <param name="useSynchronizationContext"></param>
        public void Register(Action<object> action, object state, bool useSynchronizationContext)
        {
            Review.NotNullArgument(action);
            _ct.Register(action, state, useSynchronizationContext);
        }

        /// <summary>
        /// Create a task that will to be completed when the source state unset the pause state or if the
        /// process will notified of request cancellation.
        /// If the process has been cancelled then immediately the task is completed.
        /// </summary>
        /// <param name="cancellation">Additional cancellation token to wait for a response.</param>
        /// <returns>
        /// A task with a completion base on pause/cancellation state.
        /// </returns>
        public async Task<bool> ReturnPauseAsync(CancellationToken cancellation = default)
        {
          
            // check cancellation requested
            if (_ct.IsCancellationRequested)
            {
                return false;
            }

            if (_frontHandler.IsSet is false)
            {
                _frontHandler.Set();
            }

            // use the extension for wait handler
            // bind the cancellation tokens
            // first the passed as argument and internal
            return await _pauseHandler.WaitHandle.WaitOneAsync(CancellationTokenSource.CreateLinkedTokenSource(cancellation, _ct).Token);
        }

        /// <summary>
        /// Create a task that will to be completed when the source state unset the pause state or if the
        /// process will notified of request cancellation.
        /// If the process has been cancelled then immediately the task is completed.
        /// </summary>
        /// <param name="ms">The milliseconds to wait until has a response.</param>
        /// <returns>
        /// A task with a completion base on pause/cancellation state.
        /// </returns>
        public async Task<bool> ReturnPauseAsync(int ms)
        {

            // check cancellation requested
            if (_ct.IsCancellationRequested)
            {
                return false;
            }

            if (_frontHandler.IsSet is false)
            {
                _frontHandler.Set();
            }

            // use the extension for wait handler
            // use wait millseconds unit
            return await _pauseHandler.WaitHandle.WaitOneAsync(ms, _ct);
        }
    }
}
